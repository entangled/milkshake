-- ~\~ language=Haskell filename=src/Milkshake/Data.hs
-- ~\~ begin <<lit/milkshake.md|src/Milkshake/Data.hs>>[0]
{-| This submodule contains all type definitions and Dhall counterparts.
 -}
{-# LANGUAGE DuplicateRecordFields,OverloadedLabels #-}
{-# LANGUAGE DerivingStrategies,DerivingVia,DataKinds,UndecidableInstances #-}

module Milkshake.Data where

import RIO
import qualified RIO.Text as T
import qualified RIO.Map as M

import Data.Monoid.Generic (GenericSemigroup(..), GenericMonoid(..))
import Dhall (FromDhall, ToDhall, Decoder, union, constructor, auto, input, list)

-- ~\~ begin <<lit/milkshake.md|haskell-types>>[0]
{-| A virtual target is one that is not backed up by a file, but rather by
 something that could be a file. One example would be an entry in an sqlite
 database. This may be a future feature.
 -}
data Virtual = Virtual
    { name :: Text
    , exists :: Text
    , content :: Text }
    deriving (Generic, Show, Eq)

instance FromDhall Virtual
instance ToDhall Virtual

{-| A target is either a file, some virtual content, or a phony target.
 -}
data Target
    = File Text
    | Generic Virtual
    | Phony Text
    deriving (Generic, Show, Eq)

instance FromDhall Target
instance ToDhall Target
-- ~\~ end
-- ~\~ begin <<lit/milkshake.md|haskell-types>>[1]
{-| An `Action` is a node in our workflow. -}
data Action = Action
    { target :: [ Target ]          -- ^ list of targets generated by executing the script
    , dependency :: [ Target ]      -- ^ list of dependencies
    , script :: Maybe Text          -- ^ the script to execute
    } deriving (Generic, Show)

instance FromDhall Action
-- ~\~ end
-- ~\~ begin <<lit/milkshake.md|haskell-types>>[2]
{-| Function type for generating a script to convert a `Rule` into a specific
 `Target`.
 -}
type Generator = [Target] -> [Target] -> Maybe Text

{-| A `Rule` is a parametric `Action`. Given a list of targets and dependencies,
    the generator creates the corresponding script. -}
data Rule = Rule
    { name :: Text                  -- ^ a unique name for this rule
    , gen :: Generator              -- ^ the generator function for the script
    } deriving (Generic)

instance FromDhall Rule
-- ~\~ end
-- ~\~ begin <<lit/milkshake.md|haskell-types>>[3]
{-| The `Call` is like a function call, where the `Rule` is the function
    and `target` and `dependecy` are the arguments. -}
data Call = Call
    { name :: Text                  -- ^ the name of the rule to trigger
    , target :: [ Target ]          -- ^ the targets
    , dependency :: [ Target ]      -- ^ the dependencies
    } deriving (Generic, Show)

instance FromDhall Call
-- ~\~ end
-- ~\~ begin <<lit/milkshake.md|haskell-types>>[4]
{-| The Milkshake script is an unordered list of statements. The 'Stmt' type 
 encodes statements in a Milkshake script.
 -}
data Stmt
    = StmtAction Action         {-^ -}
    | StmtRule Rule
    | StmtCall Call
    | StmtInclude FilePath
    | StmtMain [FilePath]
    -- ~\~ begin <<lit/milkshake.md|stmt-type>>[0]
    | StmtWatch Watch
    -- ~\~ end

{-| To decode a list of Milkshake statements from the Dhall configuration
    use this decoder.

  >>> input (list stmt) "(entangled.dhall).milkshake"
  -}
stmt :: Decoder Stmt
stmt = union (
       (StmtAction  <$> constructor "Action" auto)
    <> (StmtRule    <$> constructor "Rule" auto)
    <> (StmtCall <$> constructor "Call" auto)
    <> (StmtInclude <$> constructor "Include" auto)
    <> (StmtMain    <$> constructor "Main" auto)
    -- ~\~ begin <<lit/milkshake.md|stmt-decoder>>[0]
    <> (StmtWatch   <$> constructor "Watch" auto)
    -- ~\~ end
    )

{-| Read a list of statements from a script. -}
readStmts :: (MonadIO m) => Text -> m [Stmt]
readStmts path = liftIO $ input (list stmt) path
-- ~\~ end
-- ~\~ begin <<lit/milkshake.md|haskell-types>>[5]
{-| Transposed data record of a list of `Stmt`. -}
data Config = Config
    { rules      :: M.Map Text Generator
    , triggers   :: [Call]
    , actions    :: [Action]
    , includes   :: [FilePath]
    , mainTarget :: [FilePath]
    , watches    :: [Watch] }
    deriving (Generic)
    deriving Semigroup via GenericSemigroup Config
    deriving Monoid    via GenericMonoid Config

{-| Groups a list of 'Stmt' into a 'Config' record. -}
stmtsToConfig :: [Stmt] -> Config
stmtsToConfig = foldMap toConfig
    where toConfig (StmtAction a) = mempty { actions = [a] }
          toConfig (StmtRule Rule {..})   = mempty { rules = M.singleton name gen }
          toConfig (StmtCall t) = mempty { triggers = [t] }
          toConfig (StmtInclude i) = mempty { includes = [i] }
          toConfig (StmtMain m) = mempty { mainTarget = m }
          toConfig (StmtWatch w) = mempty { watches = [w] }

{-| Read a script directly to `Config` record. -}
readConfig :: (MonadIO m) => Text -> m Config
readConfig f = stmtsToConfig <$> readStmts f
-- ~\~ end
-- ~\~ begin <<lit/milkshake.md|haskell-types>>[6]
{-| A `Watch` is used to keep targets up-to-date when source files change.
 -}
data Watch = Watch
    { paths :: [Text]           -- ^ lists of paths to monitor
    , target :: Target          -- ^ target to build on file event
    } deriving (Generic)

instance FromDhall Watch
-- ~\~ end
-- ~\~ end
